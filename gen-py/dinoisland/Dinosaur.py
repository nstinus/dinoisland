#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  Dinosaur Island service

  This is the API used by clients to interact with the Dinosaur Island
  server. Functions have two attributes, whether they are actual game
  functions which cost calories to use, and whether they take up a dinosaur's
  turn, causing that connection thread to sleep until the next game turn.

  All dinosaurs have two resources, their size and their available calories.
  In addition, all dinosaurs have an individual lifespan before that
  particular instance of the dinosaur will die of old age. In order for your
  species to survive and score points, it must eventually lay eggs.

  Should your dinosaur not have enough calories to perform a given action, it
  will die of starvation. If your dinosaur simply idles, it will eventually
  die of old age.

  Eventually, your species time limit will expire, and all instances of your
  dinosaur species will die off at the same time. One of your client(s) will
  call an action API and the GameOverException will be returned, informing you
  that your species died off, what your high score is, and whether your
  species scored high enough to "solve" the puzzle, and what the top 10 scores
  are for this island.
  """
  def registerClient(self, email, highScoreName, type):
    """
    Register Client

    Costs calories: No
    Uses up turn: No

    This function must be the very first thing called by the first client that
    connects to the Dinosaur Island server. This function is slightly
    different from the instructions on the Public Thrift Server, but serves an
    identical purpose. In addition to the required email, it also requires
    a string of what to display in the high score table should your species
    rank in the top 10, as well as a chosen dinosaur type (herbivore or
    carnivore).

    Parameters:
     - email
     - highScoreName
     - type
    """
    pass

  def hatch(self, eggID):
    """
    Hatch an egg (take over a previously laid egg)

    Costs calories: No
    Uses up turn: No

    Allows a client connection to take control of an egg, identified by the
    egg ID parameter. Returns the DinosaurState of the newly controlled
    dinosaur if successful, throws an exception otherwise.

    Parameters:
     - eggID
    """
    pass

  def egg(self, direction, calories_given):
    """
    Lay an egg

    Costs calories: Yes
    Uses up turn: Yes

    Lays an egg in the specified direction, in addition to giving the new
    egg some calories to help it survive. This function costs calories to use
    and your dinosaur is responsible for ensuring it has enough to call this
    function without starving to death. The cost of this function is equal to
    the eggCost value (found in any DinosaurState struct returned) plus the
    calories given to the egg. The newly hatched dinosaur will not gain all
    of these calories, up to 20% of them will be lost in the transfer.

    This function returns an EggResults on success that contains useful
    information, such as the current state of the egg laying dinosaur, the
    egg ID of the newly laid egg, among other info. Another Dinosaur Island
    client can then connect and start playing after calling the hatch func
    with the egg ID. This function throws an exception otherwise.

    Parameters:
     - direction
     - calories_given
    """
    pass

  def look(self, direction):
    """
    Look (in a direction)

    Costs calories: Yes
    Uses up turn: Yes

    If successful, the dinosaur will use up a number of calories (found in any
    DinosaurState struct returned) and return an list of Sighting structs
    representing things the dinosaur saw in that direction. Sight is treated
    as a cone radiating out from the dinosaur in question.

    How far a dinosaur can see is dependent on how big the actual dinosaur
    is, and the sizes of the objects in the cone.

    Two examples of cone shapes are given below:

                 +                  +
                ++                  ++
               +++                  +++
              D+++                  ++++
               +++                  +++++
                ++                  ++++++
                 +                  D++++++

    Parameters:
     - direction
    """
    pass

  def grow(self, ):
    """
    Grow

    Costs calories: Yes
    Uses up turn: Yes

    If successful, the dinosaur will increments its size by one. All dinosaurs
    start with a size of one. Size is used in determining how far a dinosaur
    can see (or how easily your dinosaur can be seen), as well as how likely
    a dinosaur is in winning a fight with another dinosaur. Lastly, if your
    dinosaur is eaten, it will be worth more calories the bigger it is.

    This function returns a GrowResults struct upon success and throws an
    exception otherwise.
    """
    pass

  def move(self, direction):
    """
    Move

    Costs calories: Yes
    Uses up turn: Yes

    Moves the dinosaur in the direction specified; if an entity exists in the
    target square, the dinosaur will fight with that entity.

    Plants always lose battles, no matter what moves into their square. If the
    attacker is an herbivore, it will gain calories based upon the plant's
    size. Carnivores merely destroy the plant with no calories gained.

    If one dinosaur moves into another, they will fight. Carnivores gain a
    significant boost to their odds of victory when fighting herbivores. If
    a carnivore wins over an herbivore, it will gain calories based upon the
    size of the herbivore, and how many calories the herbivore had at time of
    death.

    If your dinosaur attempts to move into impassable terrain, the
    MoveResults struct will contain a success boolean of false, indicating
    the dinosaur did not actually change positions.

    Parameters:
     - direction
    """
    pass


class Client(Iface):
  """
  Dinosaur Island service

  This is the API used by clients to interact with the Dinosaur Island
  server. Functions have two attributes, whether they are actual game
  functions which cost calories to use, and whether they take up a dinosaur's
  turn, causing that connection thread to sleep until the next game turn.

  All dinosaurs have two resources, their size and their available calories.
  In addition, all dinosaurs have an individual lifespan before that
  particular instance of the dinosaur will die of old age. In order for your
  species to survive and score points, it must eventually lay eggs.

  Should your dinosaur not have enough calories to perform a given action, it
  will die of starvation. If your dinosaur simply idles, it will eventually
  die of old age.

  Eventually, your species time limit will expire, and all instances of your
  dinosaur species will die off at the same time. One of your client(s) will
  call an action API and the GameOverException will be returned, informing you
  that your species died off, what your high score is, and whether your
  species scored high enough to "solve" the puzzle, and what the top 10 scores
  are for this island.
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def registerClient(self, email, highScoreName, type):
    """
    Register Client

    Costs calories: No
    Uses up turn: No

    This function must be the very first thing called by the first client that
    connects to the Dinosaur Island server. This function is slightly
    different from the instructions on the Public Thrift Server, but serves an
    identical purpose. In addition to the required email, it also requires
    a string of what to display in the high score table should your species
    rank in the top 10, as well as a chosen dinosaur type (herbivore or
    carnivore).

    Parameters:
     - email
     - highScoreName
     - type
    """
    self.send_registerClient(email, highScoreName, type)
    return self.recv_registerClient()

  def send_registerClient(self, email, highScoreName, type):
    self._oprot.writeMessageBegin('registerClient', TMessageType.CALL, self._seqid)
    args = registerClient_args()
    args.email = email
    args.highScoreName = highScoreName
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerClient(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = registerClient_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.alreadyRegistered != None:
      raise result.alreadyRegistered
    raise TApplicationException(TApplicationException.MISSING_RESULT, "registerClient failed: unknown result");

  def hatch(self, eggID):
    """
    Hatch an egg (take over a previously laid egg)

    Costs calories: No
    Uses up turn: No

    Allows a client connection to take control of an egg, identified by the
    egg ID parameter. Returns the DinosaurState of the newly controlled
    dinosaur if successful, throws an exception otherwise.

    Parameters:
     - eggID
    """
    self.send_hatch(eggID)
    return self.recv_hatch()

  def send_hatch(self, eggID):
    self._oprot.writeMessageBegin('hatch', TMessageType.CALL, self._seqid)
    args = hatch_args()
    args.eggID = eggID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_hatch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = hatch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.badEgg != None:
      raise result.badEgg
    if result.youAreDead != None:
      raise result.youAreDead
    if result.gameOver != None:
      raise result.gameOver
    raise TApplicationException(TApplicationException.MISSING_RESULT, "hatch failed: unknown result");

  def egg(self, direction, calories_given):
    """
    Lay an egg

    Costs calories: Yes
    Uses up turn: Yes

    Lays an egg in the specified direction, in addition to giving the new
    egg some calories to help it survive. This function costs calories to use
    and your dinosaur is responsible for ensuring it has enough to call this
    function without starving to death. The cost of this function is equal to
    the eggCost value (found in any DinosaurState struct returned) plus the
    calories given to the egg. The newly hatched dinosaur will not gain all
    of these calories, up to 20% of them will be lost in the transfer.

    This function returns an EggResults on success that contains useful
    information, such as the current state of the egg laying dinosaur, the
    egg ID of the newly laid egg, among other info. Another Dinosaur Island
    client can then connect and start playing after calling the hatch func
    with the egg ID. This function throws an exception otherwise.

    Parameters:
     - direction
     - calories_given
    """
    self.send_egg(direction, calories_given)
    return self.recv_egg()

  def send_egg(self, direction, calories_given):
    self._oprot.writeMessageBegin('egg', TMessageType.CALL, self._seqid)
    args = egg_args()
    args.direction = direction
    args.calories_given = calories_given
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_egg(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = egg_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.youAreDead != None:
      raise result.youAreDead
    if result.gameOver != None:
      raise result.gameOver
    raise TApplicationException(TApplicationException.MISSING_RESULT, "egg failed: unknown result");

  def look(self, direction):
    """
    Look (in a direction)

    Costs calories: Yes
    Uses up turn: Yes

    If successful, the dinosaur will use up a number of calories (found in any
    DinosaurState struct returned) and return an list of Sighting structs
    representing things the dinosaur saw in that direction. Sight is treated
    as a cone radiating out from the dinosaur in question.

    How far a dinosaur can see is dependent on how big the actual dinosaur
    is, and the sizes of the objects in the cone.

    Two examples of cone shapes are given below:

                 +                  +
                ++                  ++
               +++                  +++
              D+++                  ++++
               +++                  +++++
                ++                  ++++++
                 +                  D++++++

    Parameters:
     - direction
    """
    self.send_look(direction)
    return self.recv_look()

  def send_look(self, direction):
    self._oprot.writeMessageBegin('look', TMessageType.CALL, self._seqid)
    args = look_args()
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_look(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = look_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.youAreDead != None:
      raise result.youAreDead
    if result.gameOver != None:
      raise result.gameOver
    raise TApplicationException(TApplicationException.MISSING_RESULT, "look failed: unknown result");

  def grow(self, ):
    """
    Grow

    Costs calories: Yes
    Uses up turn: Yes

    If successful, the dinosaur will increments its size by one. All dinosaurs
    start with a size of one. Size is used in determining how far a dinosaur
    can see (or how easily your dinosaur can be seen), as well as how likely
    a dinosaur is in winning a fight with another dinosaur. Lastly, if your
    dinosaur is eaten, it will be worth more calories the bigger it is.

    This function returns a GrowResults struct upon success and throws an
    exception otherwise.
    """
    self.send_grow()
    return self.recv_grow()

  def send_grow(self, ):
    self._oprot.writeMessageBegin('grow', TMessageType.CALL, self._seqid)
    args = grow_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grow(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = grow_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.youAreDead != None:
      raise result.youAreDead
    if result.gameOver != None:
      raise result.gameOver
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grow failed: unknown result");

  def move(self, direction):
    """
    Move

    Costs calories: Yes
    Uses up turn: Yes

    Moves the dinosaur in the direction specified; if an entity exists in the
    target square, the dinosaur will fight with that entity.

    Plants always lose battles, no matter what moves into their square. If the
    attacker is an herbivore, it will gain calories based upon the plant's
    size. Carnivores merely destroy the plant with no calories gained.

    If one dinosaur moves into another, they will fight. Carnivores gain a
    significant boost to their odds of victory when fighting herbivores. If
    a carnivore wins over an herbivore, it will gain calories based upon the
    size of the herbivore, and how many calories the herbivore had at time of
    death.

    If your dinosaur attempts to move into impassable terrain, the
    MoveResults struct will contain a success boolean of false, indicating
    the dinosaur did not actually change positions.

    Parameters:
     - direction
    """
    self.send_move(direction)
    return self.recv_move()

  def send_move(self, direction):
    self._oprot.writeMessageBegin('move', TMessageType.CALL, self._seqid)
    args = move_args()
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_move(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = move_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.youAreDead != None:
      raise result.youAreDead
    if result.gameOver != None:
      raise result.gameOver
    raise TApplicationException(TApplicationException.MISSING_RESULT, "move failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["registerClient"] = Processor.process_registerClient
    self._processMap["hatch"] = Processor.process_hatch
    self._processMap["egg"] = Processor.process_egg
    self._processMap["look"] = Processor.process_look
    self._processMap["grow"] = Processor.process_grow
    self._processMap["move"] = Processor.process_move

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_registerClient(self, seqid, iprot, oprot):
    args = registerClient_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = registerClient_result()
    try:
      result.success = self._handler.registerClient(args.email, args.highScoreName, args.type)
    except AlreadyRegisteredException, alreadyRegistered:
      result.alreadyRegistered = alreadyRegistered
    oprot.writeMessageBegin("registerClient", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_hatch(self, seqid, iprot, oprot):
    args = hatch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hatch_result()
    try:
      result.success = self._handler.hatch(args.eggID)
    except BadEggException, badEgg:
      result.badEgg = badEgg
    except YouAreDeadException, youAreDead:
      result.youAreDead = youAreDead
    except GameOverException, gameOver:
      result.gameOver = gameOver
    oprot.writeMessageBegin("hatch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_egg(self, seqid, iprot, oprot):
    args = egg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = egg_result()
    try:
      result.success = self._handler.egg(args.direction, args.calories_given)
    except YouAreDeadException, youAreDead:
      result.youAreDead = youAreDead
    except GameOverException, gameOver:
      result.gameOver = gameOver
    oprot.writeMessageBegin("egg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_look(self, seqid, iprot, oprot):
    args = look_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = look_result()
    try:
      result.success = self._handler.look(args.direction)
    except YouAreDeadException, youAreDead:
      result.youAreDead = youAreDead
    except GameOverException, gameOver:
      result.gameOver = gameOver
    oprot.writeMessageBegin("look", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grow(self, seqid, iprot, oprot):
    args = grow_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grow_result()
    try:
      result.success = self._handler.grow()
    except YouAreDeadException, youAreDead:
      result.youAreDead = youAreDead
    except GameOverException, gameOver:
      result.gameOver = gameOver
    oprot.writeMessageBegin("grow", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_move(self, seqid, iprot, oprot):
    args = move_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = move_result()
    try:
      result.success = self._handler.move(args.direction)
    except YouAreDeadException, youAreDead:
      result.youAreDead = youAreDead
    except GameOverException, gameOver:
      result.gameOver = gameOver
    oprot.writeMessageBegin("move", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class registerClient_args:
  """
  Attributes:
   - email
   - highScoreName
   - type
  """

  thrift_spec = None
  def __init__(self, email=None, highScoreName=None, type=None,):
    self.email = email
    self.highScoreName = highScoreName
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.highScoreName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerClient_args')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, -3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.highScoreName != None:
      oprot.writeFieldBegin('highScoreName', TType.STRING, -2)
      oprot.writeString(self.highScoreName)
      oprot.writeFieldEnd()
    if self.email != None:
      oprot.writeFieldBegin('email', TType.STRING, -1)
      oprot.writeString(self.email)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerClient_result:
  """
  Attributes:
   - success
   - alreadyRegistered
  """

  thrift_spec = None
  def __init__(self, success=None, alreadyRegistered=None,):
    self.success = success
    self.alreadyRegistered = alreadyRegistered

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RegisterClientResults()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.alreadyRegistered = AlreadyRegisteredException()
          self.alreadyRegistered.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerClient_result')
    if self.alreadyRegistered != None:
      oprot.writeFieldBegin('alreadyRegistered', TType.STRUCT, -1)
      self.alreadyRegistered.write(oprot)
      oprot.writeFieldEnd()
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hatch_args:
  """
  Attributes:
   - eggID
  """

  thrift_spec = None
  def __init__(self, eggID=None,):
    self.eggID = eggID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.I64:
          self.eggID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hatch_args')
    if self.eggID != None:
      oprot.writeFieldBegin('eggID', TType.I64, -1)
      oprot.writeI64(self.eggID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hatch_result:
  """
  Attributes:
   - success
   - badEgg
   - youAreDead
   - gameOver
  """

  thrift_spec = None
  def __init__(self, success=None, badEgg=None, youAreDead=None, gameOver=None,):
    self.success = success
    self.badEgg = badEgg
    self.youAreDead = youAreDead
    self.gameOver = gameOver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DinosaurState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.badEgg = BadEggException()
          self.badEgg.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.youAreDead = YouAreDeadException()
          self.youAreDead.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.gameOver = GameOverException()
          self.gameOver.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hatch_result')
    if self.gameOver != None:
      oprot.writeFieldBegin('gameOver', TType.STRUCT, -3)
      self.gameOver.write(oprot)
      oprot.writeFieldEnd()
    if self.youAreDead != None:
      oprot.writeFieldBegin('youAreDead', TType.STRUCT, -2)
      self.youAreDead.write(oprot)
      oprot.writeFieldEnd()
    if self.badEgg != None:
      oprot.writeFieldBegin('badEgg', TType.STRUCT, -1)
      self.badEgg.write(oprot)
      oprot.writeFieldEnd()
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class egg_args:
  """
  Attributes:
   - direction
   - calories_given
  """

  thrift_spec = None
  def __init__(self, direction=None, calories_given=None,):
    self.direction = direction
    self.calories_given = calories_given

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.I32:
          self.direction = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.I32:
          self.calories_given = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('egg_args')
    if self.calories_given != None:
      oprot.writeFieldBegin('calories_given', TType.I32, -2)
      oprot.writeI32(self.calories_given)
      oprot.writeFieldEnd()
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, -1)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class egg_result:
  """
  Attributes:
   - success
   - youAreDead
   - gameOver
  """

  thrift_spec = None
  def __init__(self, success=None, youAreDead=None, gameOver=None,):
    self.success = success
    self.youAreDead = youAreDead
    self.gameOver = gameOver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EggResults()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.youAreDead = YouAreDeadException()
          self.youAreDead.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.gameOver = GameOverException()
          self.gameOver.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('egg_result')
    if self.gameOver != None:
      oprot.writeFieldBegin('gameOver', TType.STRUCT, -2)
      self.gameOver.write(oprot)
      oprot.writeFieldEnd()
    if self.youAreDead != None:
      oprot.writeFieldBegin('youAreDead', TType.STRUCT, -1)
      self.youAreDead.write(oprot)
      oprot.writeFieldEnd()
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class look_args:
  """
  Attributes:
   - direction
  """

  thrift_spec = None
  def __init__(self, direction=None,):
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.I32:
          self.direction = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('look_args')
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, -1)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class look_result:
  """
  Attributes:
   - success
   - youAreDead
   - gameOver
  """

  thrift_spec = None
  def __init__(self, success=None, youAreDead=None, gameOver=None,):
    self.success = success
    self.youAreDead = youAreDead
    self.gameOver = gameOver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LookResults()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.youAreDead = YouAreDeadException()
          self.youAreDead.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.gameOver = GameOverException()
          self.gameOver.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('look_result')
    if self.gameOver != None:
      oprot.writeFieldBegin('gameOver', TType.STRUCT, -2)
      self.gameOver.write(oprot)
      oprot.writeFieldEnd()
    if self.youAreDead != None:
      oprot.writeFieldBegin('youAreDead', TType.STRUCT, -1)
      self.youAreDead.write(oprot)
      oprot.writeFieldEnd()
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grow_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grow_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grow_result:
  """
  Attributes:
   - success
   - youAreDead
   - gameOver
  """

  thrift_spec = None
  def __init__(self, success=None, youAreDead=None, gameOver=None,):
    self.success = success
    self.youAreDead = youAreDead
    self.gameOver = gameOver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GrowResults()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.youAreDead = YouAreDeadException()
          self.youAreDead.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.gameOver = GameOverException()
          self.gameOver.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grow_result')
    if self.gameOver != None:
      oprot.writeFieldBegin('gameOver', TType.STRUCT, -2)
      self.gameOver.write(oprot)
      oprot.writeFieldEnd()
    if self.youAreDead != None:
      oprot.writeFieldBegin('youAreDead', TType.STRUCT, -1)
      self.youAreDead.write(oprot)
      oprot.writeFieldEnd()
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class move_args:
  """
  Attributes:
   - direction
  """

  thrift_spec = None
  def __init__(self, direction=None,):
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.I32:
          self.direction = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('move_args')
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, -1)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class move_result:
  """
  Attributes:
   - success
   - youAreDead
   - gameOver
  """

  thrift_spec = None
  def __init__(self, success=None, youAreDead=None, gameOver=None,):
    self.success = success
    self.youAreDead = youAreDead
    self.gameOver = gameOver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MoveResults()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.youAreDead = YouAreDeadException()
          self.youAreDead.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.gameOver = GameOverException()
          self.gameOver.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('move_result')
    if self.gameOver != None:
      oprot.writeFieldBegin('gameOver', TType.STRUCT, -2)
      self.gameOver.write(oprot)
      oprot.writeFieldEnd()
    if self.youAreDead != None:
      oprot.writeFieldBegin('youAreDead', TType.STRUCT, -1)
      self.youAreDead.write(oprot)
      oprot.writeFieldEnd()
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
